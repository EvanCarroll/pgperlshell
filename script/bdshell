#!/usr/bin/env perl
use feature ':5.10';
use 5.10.0;
use strict;
use warnings;

use autodie;
use Carp;
use DBD::Pg;
use Text::CSV;
use IO::File;
use Getopt::Long;
use Pod::Usage;
use List::Util;

our $VERSION = '0.01';

my ($un, $db, $pw, $help, $command, $file, $DEBUG);
my $result = GetOptions(
	'username|U=s'   => \$un
	, 'dbname|d=s'   => \$db
	, 'password|P=s' => \$pw
	, 'command|c=s'  => \$command
	, 'file|f=s'     => \$file
	, 'help|?'       => \$help
	, 'debug'        => \$DEBUG
);
$DEBUG //= $ENV{DEBUG} || 0;
$db    //= $ENV{USER};
$un    //= $ENV{USER};
pod2usage(-verbose => 2) if $help;

my $dbh = DBI->connect("dbi:Pg:dbname=$db", $un, $pw, {RaiseError=>1})
	or die DBI::errstr
;

if ( $dbh->ping == 1 ) {
	say 'Connection established' if $DEBUG;
}
else {
	die 'not connected';
}

my $grammar = do {
	use Regexp::Grammars;
	qr{
		(?:
(?:<action=(\\COPY)> <.ws> <table=literal> <.ws> <columns=pcolumns>? <.ws> FROM <.ws> <source> <.ws> (?: (?:WITH)? <.ws> (<[with=with_options]>+ % \s) )? ) |
(?:<action=(\\ECHO)> <.ws> <string=(.+)> ) |
(?:<action=(SET)> <.ws> <effect=(SET|LOCAL)>? <.ws> <key=literal> <.ws> (TO|=) <.ws> (?:<value=pair>|<value=literal>) )
		)

		<rule: with_options>    <format>|<oids>|<delimiter>|<null>|<header>|<quote>|<escape>|<force_quote>|<force_not_null>|<encoding>|<custom_perl>|<custom_tcsv>
		<rule: custom_perl>     -PERL_<key=(\w+)> =? <value=pair>|-PERL_<key=(\w+)>
		<rule: custom_tcsv>     -TCSV_<key=(\w+)> = <value=pair>|-TCSV_<key=(\w+)>

		<rule: format>          FORMAT <MATCH=literal>
		<rule: oids>            OIDS <MATCH=boolean>
		<rule: delimiter>       DELIMITER <MATCH=pair>
		<rule: null>            NULL <MATCH=pair>
		<rule: header>          HEADER|HEADER <MATCH=boolean>
		<rule: quote>           QUOTE <MATCH=pair>
		<rule: escape>          ESCAPE <MATCH=pair>
		<rule: force_quote>     FORCE QUOTE <MATCH=columns>
		<rule: force_not_null>  FORCE NOT NULL <MATCH=columns>
		<rule: encoding>        ENCODING <MATCH=literal>

		<token: source>         stdin|<MATCH=literal>
		<token: as>             AS

		<rule: columns>         <[MATCH=(\w+)]>+ % ,
		<rule: pcolumns>        \( <MATCH=columns> \)

		<rule: pair>            <_delim=(\$\$|"|')> <MATCH=(.+?(?=(??{quotemeta $MATCH{_delim}})))> (??{ quotemeta $MATCH{_delim} })
		<rule: query>           \( <MATCH=(.+?(?=(??{quotemeta $MATCH{_delim}})))> \)
		<token: literal>        \S+
		<token: boolean>        TRUE|t|true|y|yes|1|FALSE|f|false|no|0
	}xmsi;
};

# Force Quote not yet supported at all.

## Read from file if provided else, read from STDIN
my $io;
if ( not defined $command ) {
	if ( $file ) {
		$io = IO::File->new( $file, '<' );
		say "Reading from file" if $DEBUG;
	}
	else {
		IO::Handle->new->fdopen( fileno(STDIN), 'r' );
		say "Falling back to STDIN" if $DEBUG;
	}
}

## REPL stuff
while ( my $input = ( $command || defined $io && $io->getline ) ) {
	undef $command;
	next unless $input =~ /\w/;

	say "LINE:\n\t$input" if $DEBUG;
	
	$input =~ $grammar;

	if ( my $action = $/{action} ) {
		my $action = lc $/{action};
		$action =~ s/^\\//;

		my $sub = "process_action_$action";

		{
			no strict 'refs';
			*{"main::$sub"}->( \%/, $input );
		}

		undef %/;
		die 'EOF' if defined $io && $io->eof;
	}
	else {
		_process_default( undef, $input );
	}

}

sub process_action_set {
	my $sql = shift;
	s/;.*// for $sql->{key}, $sql->{value};
	$dbh->do( sprintf( 'SET %s = %s', $sql->{key}, $sql->{value} ) );
}

sub process_action_echo {
	my $sql = shift;
	say $sql->{string};	
}

sub process_action_copy {
	my $sql = shift;

	my $tcsv_args = { binary => 1, blank_is_undef => 1 };
	my $perl_args;

	## SQL processing
	foreach my $opt ( @{$sql->{with}} ) {
		given ( $opt ) {
			when ( qr/binary|oids|force_not_null|force_quote/i ) {
				die "Option $opt not yet supported\n";
				## Force not null would be easily supported
				## but it requires knowing columns names
				## Even if not present in the sql command
			}
			when ( qr/delimiter/i ) {
				$tcsv_args->{sep_char} = $opt->{delimiter};
			}
			when ( qr/null/i ) {
				$tcsv_args->{empty_is_undef} = 1
					if $opt->{null}
				;
			}
			when ( qr/quote/i ) {
				$tcsv_args->{quote_char} = $opt->{quote};
				# The default escape should be the quote per pg docs
				$tcsv_args->{escape_char} //= $opt->{quote};
			}
			when ( qr/escape/i ) { $tcsv_args->{escape_char} = $opt->{escape} }
			when ( qr/header/i ) { $perl_args->{header}=1 }
			when ( qr/perl/i ) {
				$_=$opt->{custom_perl};
				$perl_args->{$_->{key}} = $_->{value}//1;
			}
			when ( qr/tcsv/i ) {
				$_=$opt->{custom_tcsv};
				$tcsv_args->{$_->{key}} = $_->{value}//1;
			}
			default {
				die "Option $opt not supported\n";
			}

		}
	}

	## [I]nput and [O]utput
	my $icsv = Text::CSV->new($tcsv_args)
		or die "Cannot use CSV: ".Text::CSV->error_diag()
	;
	my $ocsv = Text::CSV->new({binary=>1});

	my $fh = IO::File->new( $sql->{source}, '<' )
		or die "$! " . $sql->{source} . "\n"
	;

	## Discards the header row, and sets Text::CSV's column_names
	my @header;
	if ( $perl_args->{header} ) {

		@header = $perl_args->{header_lowercase}
			? map lc, @{$icsv->getline($fh)}
			: @{$icsv->getline($fh)}
		;
		
		$icsv->column_names( @header );

		## This code works if you have a header in the CSV file
		## and the column list is specified in the copy-command
		## then, it resolves the names in input_order to
		## numerical values
		my @arr;
		if ( $perl_args->{input_order} !~ /\\/ ) {
			COL: foreach my $col_name ( @{[split ',\s*', $perl_args->{input_order}]} ) {
				for ( my $i = 0; $i <= @header; $i++ ) {
					if ( $header[$i] eq $col_name ) {
						push @arr, $i+1; # the \1 is 1 based.
						next COL;
					}
				}
				die "Failed to find column $col_name\n";
			}
			$perl_args->{input_order} = join ' ', map "\\$_", @arr;
		}

	}
	
	## Skips lines if the option is set
	if ( $perl_args->{skip_lines} ) {
		$fh->getline while $perl_args->{skip_lines}--;
	}
	
	my $new_copy = sprintf (
		q[ COPY %s %s FROM STDIN WITH CSV QUOTE AS '"' ]
		, $sql->{table}
		, exists $sql->{columns} ? '(' . join (', ', @{$sql->{columns}}) . ')' : ''
	);

	$dbh->do( $new_copy );

	while ( not $fh->eof ) {

		my $tuple = $icsv->getline($fh);

		next unless List::Util::first {defined $_} @$tuple;

		if ( $icsv->error_diag ) {
			my ( $err, $text ) = $icsv->error_diag;
			warn "Text::CSV ErrorCode: [$err], Meaning: [$text]\n";
			$icsv->SetDiag(0);
			next;
		}

		die $icsv->error_diag if $icsv->error_diag;

		my @columns;

		if ( $perl_args->{input_order} ) {
			my @index = ( $perl_args->{input_order} =~ m/\\?(\d+)\s*/g );
			## -1 because 1 is the 0th element in the csv
			@columns = map $tuple->[$_-1], @index;
		}
		else {
			@columns = @$tuple;
		}

		## will get around
		## ERROR:  extra data after last expected column
		if ( $perl_args->{ragged} ) {
			if ( $sql->{columns} ) {
				splice ( @columns, @{$sql->{columns}}, $#columns , () );
			}
			else {
				die "Failure to specify columns detected, do not know how many columns I should keep in ragged csv\n";
			}
		}

		$ocsv->combine( @columns );
		$dbh->pg_putcopydata( $ocsv->string . "\n" );
	}

	$dbh->pg_putcopyend;

}

sub _process_default {
	my ( $sql, $orig_input ) = @_;
	say "FALL THROUGH:\n\t$orig_input" if $DEBUG;
	$dbh->do( $orig_input );
}

sub AUTOLOAD {
	my ( $sql, $orig_input ) = @_;
	_process_default( $sql, $orig_input );
}

__END__

=head1 NAME

BrightDog Shell - a shell for Postgresql

=head1 SYOPSIS

	echo \COPY foo FROM test.txt WITH DELIMITER AS '~' CSV HEADER -PERL_ragged -TCSV_empty_is_undef | \
		bdshell -U username -d database
	;

	bdshell -U username -d database -c "\COPY foo FROM test.txt WITH DELIMITER AS '~' CSV HEADER -PERL_input_order '\3 \2 \1'

=head1 DESCRIPTION

Above and beyond the normal COPY syntax BrightDog adds:

=over 4

=item L<Text::CSV> syntax through B<-TCSV_key> or B<-TCSV_key = value>

Example, B<-TCSV_allow_loose_quotes> which allows "Loose Quotes" is very useful.

=item B<-PERL_key> or B<-PERL_key = value>

This is for special Perl extentions some of which are

=over 4

=item B<-PERL_ragged>

Note this option currently requires you to explicitly list the optional columns in your SQL-COPY command

=item B<-PERL_skip_lines>

Skip lines at the top of the file.

=item B<-PERL_header_lowercase>

Transforms the header of the file to lowercase.

=item B<-PERL_input_order>

B<-PERL_input_order> takes two syntaxes:

=over 4

=item

Column-backreference syntax such as C<\3 \2 \1> for the third column, followed by the second, followed by the first. Note the starting column: \1.

=item

Header name syntax 'colname1,colname2,colname3' which will permit you to reorder a CSV file. Specified with the names of the columns as they apears in the CSV header row. This format requires (a) header row in the input file, (b) ether HEADER or -PERL_header to be enabled.

=back

=back

=back

=head2 COPY

More information can be found here: http://www.postgresql.org/docs/current/interactive/sql-copy.html

	COPY table_name [ ( column [, ...] ) ]
			FROM { 'filename' | STDIN }
			[ [ WITH ] ( option [, ...] ) ]

	where option can be one of:

			FORMAT format_name
			OIDS [ boolean ]
			DELIMITER 'delimiter_character'
			NULL 'null_string'
			HEADER [ boolean ]
			QUOTE 'quote_character'
			ESCAPE 'escape_character'
			FORCE_QUOTE { ( column [, ...] ) | * }
			FORCE_NOT_NULL ( column [, ...] ) |
			ENCODING 'encoding_name'

=head1 AUTHOR

Evan Carroll <me at evancarroll.com>

http://www.evancarroll.com

=cut

	COPY tablename [ ( column [, ...] ) ]
		FROM { 'filename' | STDIN }
		[ [ WITH ]
				[ BINARY ]
				[ OIDS ]
				[ DELIMITER [ AS ] 'delimiter' ]
				[ NULL [ AS ] 'null string' ]
				[ -PERL_key [ = value ] ]
				[ CSV [ HEADER ]
					[ QUOTE [ AS ] 'quote' ]
					[ ESCAPE [ AS ] 'escape' ]
					[ FORCE NOT NULL column [, ...] ]
					[ -TCSV_key [ = value ] ]

